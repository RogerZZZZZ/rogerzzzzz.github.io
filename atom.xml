<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Work In Progress</title>
  
  
  <link href="http://rogerwip.tech/atom.xml" rel="self"/>
  
  <link href="http://rogerwip.tech/"/>
  <updated>2021-01-18T13:38:56.087Z</updated>
  <id>http://rogerwip.tech/</id>
  
  <author>
    <name>RogerZZZZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;&lt;重构 改善既有代码的设计&gt;&gt;读书笔记</title>
    <link href="http://rogerwip.tech/2021/01/17/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://rogerwip.tech/2021/01/17/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-17T13:21:42.000Z</published>
    <updated>2021-01-18T13:38:56.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>作为博客里读书笔记的第一篇文章, 算是给这个系列开一个头吧, 这里的读书比较呢主要记录的是一本书中自己觉得比较有意思的点, 写下来也是为了加深记忆, 点与点之间可能毫无逻辑可言, 大家如果读到觉得感受不是很好的话也请见谅~</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h3><p>这里文章列举了很多代码坏味道, 比如:</p><ul><li>神秘命名</li><li>重复代码</li><li>过长函数</li><li>过长参数列表</li><li>全局数据</li><li>可变数据</li><li>发散式变化</li><li>霰弹式修改<ul><li>每遇到某种变化, 都需要在不同的类中进行小修改</li></ul></li><li>依恋情节<ul><li>与其他模块或者数据交流格外频繁, 甚至超过自身模块</li></ul></li><li>数据泥团<ul><li>多个类中存在相同的数据字段</li></ul></li><li>基本类型偏执<ul><li>执着于使用基本数据类型, 还忽略了抽象</li></ul></li><li>重复的switch<ul><li>可以使用策略模式, map等方式来解决</li></ul></li><li>循环语句<ul><li>多使用pipe的方式, 类似map, reduct, filter等</li></ul></li><li>夸夸其谈的通用性<ul><li>这一点也是需要注意的, 虽然说在开始写代码之前都需要对系统有一个良好的设计, 但是并不意味着需要为以后的功能, 破坏现在代码的可读性, 过度抽象某些类, 需要做的应该是不断的重构优化.</li></ul></li><li>纯数据类<ul><li>指一个类中没有其他的逻辑, 只有数据字段的getter以及setter</li></ul></li><li>注释<ul><li>这一点在文中的说法给我留下了深刻的印象, 不应该用注释来解释阅读星极差的代码, 注释并不是”除臭剂”</li></ul></li></ul><p>接下来是一些书中提到的重构方式</p><h3 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">startDate, endDate</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ====&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">dateRange</span>)</span></span></span><br></pre></td></tr></table></figure><p>配合typescript使用, 效果更佳, 在我实际开发中使用解构来获取函数参数都比过长的参数列表更加优雅, 一方面是可以省去对函数参数顺序的记忆, 另一方面是参数的传入是非常灵活的, 可以对多个参数进行默认值的设置</p><h3 id="以对象取代基本类型"><a href="#以对象取代基本类型" class="headerlink" title="以对象取代基本类型"></a>以对象取代基本类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order.filter(<span class="function"><span class="params">o</span> =&gt;</span> <span class="string">&#x27;high&#x27;</span> === o.priority</span><br><span class="line">  || <span class="string">&#x27;rush&#x27;</span> === o.priority)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====&gt;</span></span><br><span class="line"></span><br><span class="line">order.filter(<span class="function"><span class="params">o</span> =&gt;</span> o.priority.hightThen(<span class="keyword">new</span> Priority(<span class="string">&#x27;normal&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>也许在一开始书写的时候, 第一种写法能够快速的完成需求, 但是随着业务逻辑不断复杂, 对于<code>priority</code>的判断逻辑不断增多以后, 将会逐渐失控, 如果你对Java有一定的接触, 就会很容易的联想实现<code>compare</code>的接口, 我认为都是一种理念, 对于一些数据字段进行功能的扩展</p><h3 id="拆分循环"><a href="#拆分循环" class="headerlink" title="拆分循环"></a>拆分循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> averageAge = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> totalSalary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  averageAge += p.age</span><br><span class="line">  totalSalary = p.salary</span><br><span class="line">&#125;</span><br><span class="line">averageAge /= people.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> averageAge = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  averageAge += p.age</span><br><span class="line">&#125;</span><br><span class="line">averageAge /= people.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> totalSalary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  totalSalary = p.salary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许下面的代码对于很多人来说都是一种坏味道, 甚至我现在也这样觉得, 因为理论上多执行了一次循环, 但是往往在很多的场景中, <strong>循环并不是性能的瓶颈</strong>, 分开书写之后能带来更好的维护性和可读性, 也能方便的拆分代码逻辑</p><h3 id="以多态取代条件表达式"><a href="#以多态取代条件表达式" class="headerlink" title="以多态取代条件表达式"></a>以多态取代条件表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(bird.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a type&#x27;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;b type&#x27;</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a type&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;b type&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用多态处理变体逻辑"><a href="#用多态处理变体逻辑" class="headerlink" title="用多态处理变体逻辑"></a>用多态处理变体逻辑</h3><p>当基类中存在对某种特殊情况进行判断计算时, 可以将这部分逻辑从中分离出来, 因为这样的特殊逻辑过多会混淆视听, 让基础的逻辑难以理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.voyage = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.voyage = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">getVoyageFactor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="built_in">this</span>.getVoyageFactor()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeRating</span> <span class="title">extens</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">getVoyageFactor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将查询函数和修改函数分离"><a href="#将查询函数和修改函数分离" class="headerlink" title="将查询函数和修改函数分离"></a>将查询函数和修改函数分离</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalOutstandingAndSendBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = customer.invoices.reduce(<span class="function">(<span class="params">total, each</span>) =&gt;</span> each.amount + total, <span class="number">0</span>)</span><br><span class="line">  sendBill()</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">totalOutstanding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> customer.invoices.reduce(<span class="function">(<span class="params">total, each</span>) =&gt;</span> each.amount + total, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  sendBill()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原书中有一句话我印象深刻, 明确表现出<code>有副作用</code>与<code>无副作用</code>两种函数之间的差异, 是个很好的想法.</p><p>任何有返回值的函数, 都不应该有看得到的副作用–<code>命令与查询分离</code></p><h3 id="移除标记参数"><a href="#移除标记参数" class="headerlink" title="移除标记参数"></a>移除标记参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDimension</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;height&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._height = value</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;width&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._width = value</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHeight</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._height = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWidth</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._width = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常在开发过程中, 经常会通过传入一些<code>flag</code>来是函数内部的逻辑进行180度的大转变, 往往这样参数的引入会让人难以理解到底那些函数可以调用, 应该如何调用, 正确的做法应该是将<code>flag</code>提取出反映在函数名上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deliveryDate</span>(<span class="params">order, isRush</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ====&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">rushDeliveryDate</span>(<span class="params">order</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">regularDeliveryDate</span>(<span class="params">order</span>)</span></span></span></span><br></pre></td></tr></table></figure><h3 id="保持对象完整"><a href="#保持对象完整" class="headerlink" title="保持对象完整"></a>保持对象完整</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; low, heigh &#125; = dayTempRange</span><br><span class="line">withinRange(low, heigh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===&gt;</span></span><br><span class="line">withRange(dayTempRange)</span><br></pre></td></tr></table></figure><h3 id="以命令取代函数"><a href="#以命令取代函数" class="headerlink" title="以命令取代函数"></a>以命令取代函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">score</span>(<span class="params">candidate, medicalExam, scoringGuide</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> healthLevel = <span class="number">0</span></span><br><span class="line">  <span class="comment">// long body code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scorer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">candidate, medicalExam, scoringGuide</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.candidate = candidate</span><br><span class="line">    <span class="built_in">this</span>.medicalExam = medicalExam</span><br><span class="line">    <span class="built_in">this</span>.scorginGuide = scoringGuide</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">excute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._result = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>._healthLevel = <span class="number">0</span></span><br><span class="line">    <span class="comment">// long body code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数封装成自己的对象, 有时也是有用的方法, 这种对象我们通常称之为<code>命令对象</code>, 这种对象通常只服务于单一函数, 获得对该函数的请求, 执行该函数, 就是这种对象存在的意义</p><p>与普通的函数相比, 命令对象有更强的表达能力以及更大的控制灵活性. 也可以命令对象增加更多的附加操作, 比如<code>撤销</code></p><h3 id="以委托取代子类"><a href="#以委托取代子类" class="headerlink" title="以委托取代子类"></a>以委托取代子类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">daysToShip</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.priorityDelegate)</span><br><span class="line">      ? <span class="built_in">this</span>._priorityDelegate.daysToShip</span><br><span class="line">      : <span class="built_in">this</span>._warehouse.daysToShip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityOrderDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">daysToShip</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._priorityPlan.daysToShip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的原因有两个:</p><ul><li>1.继承存在短板, 最明显的是, 继承只能用于处理一个方向上的变化, 比如说我们可能希望’人’的行为根据’年龄段’不同, 并根据’收入水平’不同, 使用继承的话, 子类需要有年轻人, 老人, 也可以是富人以及穷人, 但是不能同时采用两种继承方式</li><li><ol start="2"><li>继承给类之间引入了非常紧密的关系, 任何对超类上的修改, 都会对子类带来影响</li></ol></li></ul><h2 id="Outro"><a href="#Outro" class="headerlink" title="Outro"></a>Outro</h2><p>是一本值得细细思考的书, 也许之后我会每隔一年会再次翻阅, 相信到时候也会有新的感悟吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;作为博客里读书笔记的第一篇文章, 算是给这个系列开一个头吧, 这里的读书比较呢主要记录的是一本书中自己觉得比较有意思</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记一次HHKB`失联`的修复</title>
    <link href="http://rogerwip.tech/2021/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1HHKB-%E5%A4%B1%E8%81%94-%E7%9A%84%E4%BF%AE%E5%A4%8D/"/>
    <id>http://rogerwip.tech/2021/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1HHKB-%E5%A4%B1%E8%81%94-%E7%9A%84%E4%BF%AE%E5%A4%8D/</id>
    <published>2021-01-08T05:48:15.000Z</published>
    <updated>2021-01-17T13:18:33.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随意BB几句"><a href="#随意BB几句" class="headerlink" title="随意BB几句"></a>随意BB几句</h2><p>因为电脑黑屏的关系, 用TimeMachine进行了电脑的备份和恢复, 一切的体验都非常的好直到发现<code>HHKB</code>连不上新电脑的那一刻开始..心态炸裂, 花了大概三个小时最终终于解决了…希望以后遇到这个问题的小伙伴能顺利解决</p><a id="more"></a><h2 id="正文-问题表现"><a href="#正文-问题表现" class="headerlink" title="正文: 问题表现"></a>正文: 问题表现</h2><p>键盘: <strong>HHKB Hybrid Type-s 双模版本</strong><br>电脑: <strong>macbook</strong></p><p>表现为蓝牙一直无法稳定的链接到电脑上, 无论是有线或者无线的模式, 在系统蓝牙管理页面处可以看到<code>HHKB</code>的图标一直上下闪烁, 最终无法连接成功导致键盘无法正常工作</p><p><a href="https://imgchr.com/i/sumv5D"><img src="https://s3.ax1x.com/2021/01/08/sumv5D.png" alt="sumv5D.png"></a></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>键盘开机</li><li>按住<code>Fn + Q</code>进入配对模式, 表现为蓝色的灯一直闪烁</li><li>再按住<code>Fn + Z + ~</code>键清空键盘蓝牙配对信息, 键盘会自动关闭, 灯会变成橙色</li><li>再长按开关键重新打开键盘, 按住<code>Fn + Q</code>重新进行进入配对模式</li><li>按住<code>Fn + Control + 1/2/3/4</code>, 指定1,2,3,4任意一个序号, 之后电脑重新搜索蓝牙就可以找到你刚才用的序号命名的键盘了, 再次连接<strong>键盘就恢复了</strong></li></ul><p>这里也附上我找到的关于<code>HHKB</code>蓝牙相关设置的按键组合</p><p><a href="https://imgchr.com/i/sutEdJ"><img src="https://s3.ax1x.com/2021/01/08/sutEdJ.png" alt="sutEdJ.png"></a></p><h2 id="高级操作-常规操作"><a href="#高级操作-常规操作" class="headerlink" title="高级操作(常规操作)"></a>高级操作(常规操作)</h2><p>为什么会存在设置蓝牙序号这样的操作呢, 这其实也是<code>HHKB</code>的一个feature吧, 多设备间的快速切换, 最多可以连接四台设备(包括mac, ios, windows, android), 只需要提前对四个设备设置不同的键盘编号即可. 直接按下<code>Fn + Control + 1/2/3/4</code>就可以做到秒级的设备切换, 这是<code>filco</code>之类的键盘无法做到的.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;随意BB几句&quot;&gt;&lt;a href=&quot;#随意BB几句&quot; class=&quot;headerlink&quot; title=&quot;随意BB几句&quot;&gt;&lt;/a&gt;随意BB几句&lt;/h2&gt;&lt;p&gt;因为电脑黑屏的关系, 用TimeMachine进行了电脑的备份和恢复, 一切的体验都非常的好直到发现&lt;code&gt;HHKB&lt;/code&gt;连不上新电脑的那一刻开始..心态炸裂, 花了大概三个小时最终终于解决了…希望以后遇到这个问题的小伙伴能顺利解决&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://rogerwip.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="http://rogerwip.tech/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>用Rust写一个CLI工具</title>
    <link href="http://rogerwip.tech/2021/01/07/%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AACLI%E5%B7%A5%E5%85%B7/"/>
    <id>http://rogerwip.tech/2021/01/07/%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AACLI%E5%B7%A5%E5%85%B7/</id>
    <published>2021-01-07T14:25:44.000Z</published>
    <updated>2021-01-17T13:18:33.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><strong>Lingling insurance</strong></p><p>自己刚开始学习Rust不久, 写这个简单的cli也是为了练手, 代码不优雅也请各路大神指点, 我定虚心求教! 起初接触到rust是因为WebAssembly, 有不少人用rust编译为WSAM, 作为一个合格的前端娱乐圈工作者, 还是希望对此有一定的了解. </p><p>该CLI实现一个持久化的TODO list. 那废话不多说, 咱们开始吧!</p><a id="more"></a><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h2><h3 id="1-1-rust安装"><a href="#1-1-rust安装" class="headerlink" title="1.1 rust安装"></a>1.1 rust安装</h3><p>如果你是用的是Macos或者是linux都可以简单的通过下面的命令安装rust</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &lt;https://sh.rustup.rs&gt; -sSf | sh</span><br></pre></td></tr></table></figure><p>如果你使用的window系统, 可以上<a href="https://rustup.rs/">rustup</a>下载对应exe文件.</p><h3 id="1-2-cargo的使用"><a href="#1-2-cargo的使用" class="headerlink" title="1.2 cargo的使用"></a>1.2 cargo的使用</h3><p><code>cargo</code>是<code>rust</code>包内自带的包管理工具, 类似npm, 同时也提供了一些cli来编译或者初始化一个项目</p><blockquote><p>cargo init</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个项目</span><br><span class="line">cargo init xxx-project </span><br></pre></td></tr></table></figure><p>执行结束以后会在执行目录下生产下面的目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">  .git/</span><br><span class="line">  |</span><br><span class="line">  .gitignore</span><br><span class="line">  |</span><br><span class="line">  Cargo.toml</span><br><span class="line">  |</span><br><span class="line">  src/</span><br></pre></td></tr></table></figure><p>其中需要解释的是<code>Cargo.toml</code>文件, 其作用和<code>npm</code>中<code>package.json</code>相同, 对项目信息和包依赖进行一些说明</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rust-cli&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;rogerjluo&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br><span class="line"><span class="attr">clap</span> = <span class="string">&quot;~2.32&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">chrono</span> = <span class="string">&quot;0.4&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>cargo build</p></blockquote><p>改命令是将项目进行预编译, 安装你在toml文件中的依赖至<code>target</code>文件夹内, 并生成或者更新<code>Cargo.lock</code>文件对依赖的版本进行管理(作用类似package-lock.json).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">   Compiling proc-macro2 v1.0.24</span><br><span class="line">   Compiling autocfg v1.0.1</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">   Compiling chrono v0.4.19</span><br><span class="line">   Compiling rust-cli v0.1.0 (/Users/rogerjluo/Documents/project/rust-cli)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 28.25s</span><br></pre></td></tr></table></figure><blockquote><p>cargo run build</p></blockquote><p>编译后执行二进制文件, 比如在<code>src/main.rs</code>文件中写入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo run build</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.03s</span><br><span class="line">     Running `target/debug/rust-cli build`</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="2-文件存储和读取"><a href="#2-文件存储和读取" class="headerlink" title="2. 文件存储和读取"></a>2. 文件存储和读取</h2><p>因为我们要做一个持久化数据的todolist, 所以文件操作是必不可少的, 这里就用到了标准库中的<code>std::io::&#123;Read, Write&#125;</code>以及<code>std::fs</code>.</p><p>首先我们需要声明一些<code>struct</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InternalFile</span></span> &#123;</span><br><span class="line">  path: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> data: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> actual_size: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileSystem</span></span> &#123;</span><br><span class="line">  files: HashMap&lt;<span class="built_in">String</span>, InternalFile&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写文件</p></blockquote><p>这里使用HashMap的原因是不希望多次写文件, 所以将多次写入操作合并之后再写入.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将写入数据先写入到内存中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>, data: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">  <span class="keyword">self</span>.files.insert(</span><br><span class="line">    calculate_hash(&amp;path.to_string().as_bytes()),</span><br><span class="line">    InternalFile &#123;</span><br><span class="line">      path: path.to_string(),</span><br><span class="line">      data: data.to_string(),</span><br><span class="line">      actual_size: data.len(),</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件系统数据转存到文件</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">save</span></span>&lt;T: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(&amp;<span class="keyword">self</span>, path: T) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> f = fs::File::create(&amp;path).unwrap();</span><br><span class="line">  <span class="keyword">for</span> (_, file) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.files &#123;</span><br><span class="line">    f.write(&amp;file.data.as_bytes()).unwrap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读文件</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">load</span></span>(&amp;<span class="keyword">self</span>, path: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path_name = Path::new(&amp;path);</span><br><span class="line">  <span class="keyword">let</span> display = path_name.display();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="keyword">match</span> File::open(&amp;path_name) &#123;</span><br><span class="line">    <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">    <span class="literal">Err</span>(_why) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果文件不存在则创建一个文件</span></span><br><span class="line">      <span class="keyword">self</span>.save(path);</span><br><span class="line">      <span class="built_in">panic!</span>(<span class="string">&quot;文件不存在, 已经新建存储文件, 请重试&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  <span class="keyword">match</span> file.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">    <span class="literal">Err</span>(why) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;无法打开文件 &#123;&#125;: &#123;&#125;&quot;</span>, display,</span><br><span class="line">    why.to_string()),</span><br><span class="line">    <span class="literal">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  s <span class="comment">// 返回文件内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-JSON的序列化和反序列化"><a href="#3-JSON的序列化和反序列化" class="headerlink" title="3. JSON的序列化和反序列化"></a>3. JSON的序列化和反序列化</h2><p>当然为了方便对文件内容进行操作, 我们对写入和读取进行了序列化和反序列的过程, 使用到的是<code>serde_json</code>, 实现类似JS中的<code>JSON.parse</code>以及<code>JSON.stringify</code></p><blockquote><p>序列化</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serde_json::to_string(TodoList)</span><br></pre></td></tr></table></figure><blockquote><p>反序列化</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data: TodoList = <span class="keyword">match</span> serde_json::from_str(&amp;file) &#123;</span><br><span class="line">  <span class="literal">Ok</span>(x) =&gt; x,</span><br><span class="line">  <span class="literal">Err</span>(_why) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果文件为空或者出错, 则创建一个空的list返回</span></span><br><span class="line">    TodoList &#123;</span><br><span class="line">      todos: HashMap::new(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们是可以指定反序列化的目标结构, 如果结构不匹配则无法完成反序列化, 但是前提是需要在<code>struct</code>上加上一些声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TodoTask</span></span> &#123;</span><br><span class="line">  content: <span class="built_in">String</span>,</span><br><span class="line">  is_done: <span class="built_in">bool</span>,</span><br><span class="line">  c_time: <span class="built_in">String</span>,</span><br><span class="line">  u_time: <span class="built_in">String</span>,</span><br><span class="line">  index: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TodoList</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> todos: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Vec</span>&lt;TodoTask&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-clap"><a href="#4-clap" class="headerlink" title="4. clap"></a>4. clap</h2><p>基础的功能有了, 接下来我们需要获取命令行中传入的参数并执行不同的逻辑, <code>cargo</code>中 <code>cargo run -- [参数]</code>可以将参数传入到程序中, 但我们这里将使用一个叫做<code>clap</code>的库来简化这个过程.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> help_instru = r#<span class="string">&quot;命令名:</span></span><br><span class="line"><span class="string">    add(a)          -p [Content]                  : 添加当天的todo</span></span><br><span class="line"><span class="string">    list_all(la)                                  : 打印全部todo</span></span><br><span class="line"><span class="string">    list_daily(ld)  -p [Date: YYYY-MM-DD]         : 打印某一天的todo, 不带参数默认打印当天</span></span><br><span class="line"><span class="string">    remove(rm)      -p [Date: YYYY-MM-DD] [Index] : 删除某一项todo</span></span><br><span class="line"><span class="string">    toggle(t)       -p [Date: YYYY-MM-DD] [Index] : 改变某一项todo的状态, 完成/待完成</span></span><br><span class="line"><span class="string">    list_week(lw)   -p [Date: YYYY-MM-DD]         : 打印某一周的todo, 方便生成周报</span></span><br><span class="line"><span class="string">  &quot;</span>#;</span><br><span class="line">  <span class="keyword">let</span> matches = App::new(<span class="string">&quot;Todo&quot;</span>)</span><br><span class="line">    .version(<span class="string">&quot;0.0.1&quot;</span>)</span><br><span class="line">    .author(<span class="string">&quot;rogerjluo&quot;</span>)</span><br><span class="line">    .about(<span class="string">&quot;rust实现的todolist&quot;</span>)</span><br><span class="line">    .arg(Arg::with_name(<span class="string">&quot;MODE&quot;</span>)</span><br><span class="line">      .short(<span class="string">&quot;m&quot;</span>)</span><br><span class="line">      .long(<span class="string">&quot;mode&quot;</span>)</span><br><span class="line">      .takes_value(<span class="literal">true</span>)</span><br><span class="line">      .help(help_instru))</span><br><span class="line">    .arg(Arg::with_name(<span class="string">&quot;PARAMETERS&quot;</span>)</span><br><span class="line">      .short(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">      .long(<span class="string">&quot;params&quot;</span>)</span><br><span class="line">      .multiple(<span class="literal">true</span>)</span><br><span class="line">      .takes_value(<span class="literal">true</span>)</span><br><span class="line">      .help(<span class="string">&quot;参数&quot;</span>))</span><br><span class="line">    .get_matches();</span><br></pre></td></tr></table></figure><p>进行了声明之后, 我们如何在程序中获取到传入的参数呢</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是参数只支持单个value, 此处match的名字与之前声明的Arg::with_name(&quot;MODE&quot;)对应</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(mode) = matches.value_of(<span class="string">&quot;MODE&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">match</span> mode &#123;</span><br><span class="line">    <span class="string">&quot;add&quot;</span> =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;list_all&quot;</span> =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;没有此命令&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持multiple value</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">  <span class="keyword">let</span> date = p_list[<span class="number">0</span>]; <span class="comment">// 参数一</span></span><br><span class="line">  <span class="keyword">let</span> index = p_list[<span class="number">1</span>]; <span class="comment">// 参数二</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;请输入参数: -p [Date: YYYYMMDD] [Index] \n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-举个栗子-🌰"><a href="#5-举个栗子-🌰" class="headerlink" title="5. 举个栗子 🌰"></a>5. 举个栗子 🌰</h2><p>这里我们只列举其中的两个具体实现~ 如果感兴趣可以去仓库中查看别的代码, 代码地址在文末.</p><blockquote><p>写入一项todo</p></blockquote><p>这里我们只写入当天的todo, 所以传入的参数只需要写入的内容即可, 命令为: <code>cargo run -- -m add -p HelloWorld</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;add&quot;</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">    <span class="keyword">let</span> content = p_list[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// add_task的作用就是将新的todo插入到对应日期的todo列表中, 这里就不列举代码了</span></span><br><span class="line">    <span class="keyword">let</span> newlist = task::add_task(data, content.to_string());</span><br><span class="line">    file_system.write(<span class="string">&quot;todo&quot;</span>, &amp;serde_json::to_string(&amp;TodoList &#123;</span><br><span class="line">      todos: newlist</span><br><span class="line">    &#125;).unwrap());</span><br><span class="line">    file_system.save(file_name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;请输入参数: -p [Content] \n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行后, 我们会看到指定写入文件内会有下面的信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;todos&quot;</span>:&#123;<span class="attr">&quot;2020-12-12&quot;</span>:[&#123;<span class="attr">&quot;content&quot;</span>:<span class="string">&quot;HelloWorld&quot;</span>,<span class="attr">&quot;is_done&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;c_time&quot;</span>:<span class="string">&quot;2020-12-12 07:21:31&quot;</span>,<span class="attr">&quot;u_time&quot;</span>:<span class="string">&quot;2020-12-12 07:21:31&quot;</span>,<span class="attr">&quot;index&quot;</span>:<span class="string">&quot;0&quot;</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>列举某一天所在周的全部todo</p></blockquote><p>我们要实现这个功能, 需要计算出某一日期所在的周在该年中的index, 这里借助了<code>chrono</code>库提供的api实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::prelude::*;</span><br><span class="line"><span class="keyword">use</span> chrono::&#123;NaiveDate&#125;;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_weekday_index</span></span>(date: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> utc = NaiveDate::parse_from_str(date, <span class="string">&quot;%Y-%m-%d&quot;</span>).unwrap();</span><br><span class="line">  <span class="comment">// utc.ordinal()可以获取日期在该年中的index</span></span><br><span class="line">  <span class="keyword">let</span> day_index = utc.ordinal();</span><br><span class="line">  (day_index / <span class="number">7</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;list_week&quot;</span> | <span class="string">&quot;lw&quot;</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> date;</span><br><span class="line">  <span class="comment">// 这里判断是否传入日期参数, 没有传入默认为当天</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">    date = p_list[<span class="number">0</span>].to_string();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    date = util::get_cur_ymd();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> week_index = util::get_weekday_index(&amp;date);</span><br><span class="line">  <span class="keyword">for</span> val <span class="keyword">in</span> data.todos.keys() &#123;</span><br><span class="line">    <span class="keyword">let</span> c_week_index = util::get_weekday_index(val);</span><br><span class="line">    <span class="comment">// 判断是否在同一周, 如果是则打印</span></span><br><span class="line">    <span class="keyword">if</span> c_week_index == week_index &#123;</span><br><span class="line">      task::list_daily(&amp;data, val.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行命令为: <code>cargo run -- -m lw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo run -- -m lw               </span><br><span class="line">   Compiling rust-cli v0.1.0 (/Users/rogerjluo/Documents/project/rust-cli)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 2.00s</span><br><span class="line">     Running `target/debug/rust-cli -m lw`</span><br><span class="line"></span><br><span class="line">2020-12-12:</span><br><span class="line"></span><br><span class="line">0. [Need Handle] HelloWorld</span><br></pre></td></tr></table></figure><h2 id="6-结尾"><a href="#6-结尾" class="headerlink" title="6. 结尾"></a>6. 结尾</h2><p>文章只是介绍了项目中的部分代码以及功能, 完整版已经实现的功能包括:</p><ul><li>写入新的todo</li><li>更改todo状态, 待处理和已完成间进行切换</li><li>删除某个todo</li><li>列出所有todo</li><li>列出本周的todo list</li><li>列出某一天的todo list</li></ul><p>(这里没有列出所有的代码, 如果你感兴趣, 请移步到: <a href="https://github.com/RogerZZZZZ/rust-todo-cli">git</a>) 如果觉得还不错, 帮忙点个star吧, 初学者举步维艰</p><p>如果大家对代码有什么建议的话希望能告诉我, 这将继续鞭策我前进, 感谢~</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Lingling insurance&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自己刚开始学习Rust不久, 写这个简单的cli也是为了练手, 代码不优雅也请各路大神指点, 我定虚心求教! 起初接触到rust是因为WebAssembly, 有不少人用rust编译为WSAM, 作为一个合格的前端娱乐圈工作者, 还是希望对此有一定的了解. &lt;/p&gt;
&lt;p&gt;该CLI实现一个持久化的TODO list. 那废话不多说, 咱们开始吧!&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="http://rogerwip.tech/categories/rust/"/>
    
    <category term="瞎折腾" scheme="http://rogerwip.tech/categories/rust/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="rust" scheme="http://rogerwip.tech/tags/rust/"/>
    
    <category term="cli" scheme="http://rogerwip.tech/tags/cli/"/>
    
  </entry>
  
</feed>
