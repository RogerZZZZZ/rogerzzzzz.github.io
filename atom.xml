<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Work In Progress</title>
  
  
  <link href="http://rogerwip.tech/atom.xml" rel="self"/>
  
  <link href="http://rogerwip.tech/"/>
  <updated>2021-01-20T01:49:18.431Z</updated>
  <id>http://rogerwip.tech/</id>
  
  <author>
    <name>RogerZZZZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何写一个graphql validation模块</title>
    <link href="http://rogerwip.tech/2021/01/18/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAgraphql-validation%E6%A8%A1%E5%9D%97/"/>
    <id>http://rogerwip.tech/2021/01/18/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAgraphql-validation%E6%A8%A1%E5%9D%97/</id>
    <published>2021-01-18T13:40:43.000Z</published>
    <updated>2021-01-20T01:49:18.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这篇文章的契机是因为最近项目中使用到了<code>graphql</code>, 为了防止接口出现安全问题, 就对<code>graphql</code>的<code>validation</code>进行了一点研究. 本文就不对<code>graphql</code>进行一些介绍了, 如果感兴趣的小伙伴, 可以移步到官网进行阅读<a href="https://graphql.org/">链接</a></p><a id="more"></a><h2 id="初级的防御"><a href="#初级的防御" class="headerlink" title="初级的防御"></a>初级的防御</h2><h3 id="1-关闭内省系统"><a href="#1-关闭内省系统" class="headerlink" title="1. 关闭内省系统"></a>1. 关闭内省系统</h3><p>首先我们要知道内省是什么, 内省也可以被认为是自检系统. 通过内省我们可以简单的就获取到<code>graphql</code>支持的所有查询以及查询字段的类型, 这里举一个例子, 你可以使用<code>__schema</code>来询问<code>graphql</code>有哪些类型是可用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __schema &#123;</span><br><span class="line">    types &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__schema&quot;: &#123;</span><br><span class="line">      &quot;types&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Query&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Episode&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;ID&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;String&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; .....</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Int&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Type&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__TypeKind&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Field&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类似<code>Query</code>, <code>Episode</code>这是我们再类型系统中定义的类型</li><li><code>Int</code>, <code>String</code>这样是内建的标量, 由系统提供</li><li><code>__Type</code>, <code>__TypeKind</code>这些则为内省系统中的一部分</li></ul><p>我们如何知道一个类型支持哪些字段, 而其中的字段又是什么类型呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    fields &#123;</span><br><span class="line">      name</span><br><span class="line">      type &#123;</span><br><span class="line">        name</span><br><span class="line">        kind</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Droid&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friends&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;LIST&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friendsConnection&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;appearsIn&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;primaryFunction&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;String&quot;,</span><br><span class="line">            &quot;kind&quot;: &quot;SCALAR&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>NON_NULL</code>表示是一个非空的包装, 可以通过<code>ofType</code>来获取其类型.</p><p>上面只是举了一些内省系统中几个简单的应用, 那么说到这里, 聪明的小伙伴就会发现这样的系统能给我们带来什么了, 对了, 那就是大家最讨厌的<code>文档</code>.</p><p>schema的编写本质就能生成一份完善的文档, 这里介绍一个现成的工具可以使用, <a href="https://github.com/mhallin/graphql-docs">graphql-doc</a></p><p>我们知道文档都是对内的, 如果将所有文档暴露在外势必会引起安全问题, 所以我们在生产环境中需要关闭内省系统</p><p>这里以<code>express</code>作为例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">&#x27;body-parser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; graphqlExpress &#125; <span class="keyword">from</span> <span class="string">&#x27;graphql-server-express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> NoIntrospection <span class="keyword">from</span> <span class="string">&#x27;graphql-disable-introspection&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myGraphQLSchema = <span class="comment">// ... define or import your schema here!</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bodyParser is needed just for POST.</span></span><br><span class="line">app.use(<span class="string">&#x27;/graphql&#x27;</span>, bodyParser.json(), graphqlExpress(&#123;</span><br><span class="line">  schema: myGraphQLSchema,</span><br><span class="line">  validationRules: [ NoIntrospection ]</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(PORT);</span><br></pre></td></tr></table></figure><h3 id="2-对Query的DDos防御"><a href="#2-对Query的DDos防御" class="headerlink" title="2. 对Query的DDos防御"></a>2. 对Query的DDos防御</h3><p><code>graphql</code>带给了前端方便的同时, 也为服务端带来了很多不确定性, 比如下面的<code>query</code>无限循环下去将会给服务器带来ddos攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">query getBlogDDos &#123;</span><br><span class="line">  author(id: &quot;abc&quot;) &#123;</span><br><span class="line">    name                    # Depth: 1</span><br><span class="line">    blog &#123;                  # Depth: 2</span><br><span class="line">      author &#123;              # Depth: 3</span><br><span class="line">        name</span><br><span class="line">        blog &#123;              # Depth: 4</span><br><span class="line">          author &#123;          # Depth: 5</span><br><span class="line">            name</span><br><span class="line">            blog &#123;          # Depth: 6</span><br><span class="line">              author &#123;      # Depth: 7</span><br><span class="line">                name</span><br><span class="line">                blog &#123;      # Depth: 8</span><br><span class="line">                  # ......</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的场景解决方法也非常的简单, 通过<code>AST</code>分析<code>query</code>的深度并对其进行限制即可. 如果查询深度超过预设值, 则返回错误</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Query has depth of 8, which exceeds max depth of 5&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过深度对<code>graphql</code>的query进行安全检查虽然简单, 但是也有更加明显的缺点, 如果在根节点进行大量的查询一样会造成ddos攻击, 所以我们需要引入另外的方法来对<code>query</code>进行校验.</p><h2 id="防御加固"><a href="#防御加固" class="headerlink" title="防御加固"></a>防御加固</h2><h3 id="1-查询的复杂度计算"><a href="#1-查询的复杂度计算" class="headerlink" title="1. 查询的复杂度计算"></a>1. 查询的复杂度计算</h3><p>查询复杂度的计算方式有很多种, 这里我们只举出一个例子, 首先我们假设查询一个基础类型字段的复杂度为<code>1</code>, 深度每<code>+1</code>(深度变化可能是列表也可能是自定义的数据结构), 就导致基础的倍数<code>*10</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  author(id: &quot;abc&quot;) &#123;</span><br><span class="line">    name                 # complexity: 1</span><br><span class="line">    id                   # complexity: 1 + 1</span><br><span class="line">    posts &#123;</span><br><span class="line">      title              # complexity: 1 + 1 + 1 * 10</span><br><span class="line">      id                 # complexity: 1 + 1 + 1 * 10 + 1 * 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述<code>query</code>的复杂度为<code>22</code>, </p><h3 id="2-校验工具实现"><a href="#2-校验工具实现" class="headerlink" title="2. 校验工具实现"></a>2. 校验工具实现</h3><p>现在进入本文的重点, 我们如何实现一个这样的校验工具呢, 首先看到对一个<code>query</code>的遍历, 我们能很容易的联想到深度优先算法, <code>graphql</code>官方也提供了这样的遍历函数方便开发者使用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visit</span>(<span class="params">root, visitor, keyMap</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供了enter, leave两个函数, 当进入/离开一个node会触发</span></span><br><span class="line"><span class="keyword">const</span> editedAst = visit(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">enter</span>(<span class="params">node, key, parent, path, ancestors</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">leave</span>(<span class="params">node, key, parent, path, ancestors</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然你可以指定<code>enter</code>, <code>leave</code>函数绑定的<code>node</code>类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">visit(ast, &#123;</span><br><span class="line">  Kind: &#123;</span><br><span class="line">    <span class="function"><span class="title">enter</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// enter the &quot;Kind&quot; node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">leave</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// leave the &quot;Kind&quot; node</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来是<code>visit</code>函数在<code>validation</code>中的实际使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComplexityLimitRule</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  maxCost,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">ComplexityLimit</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> visitor = <span class="keyword">new</span> ComplexityVisitor(context);</span><br><span class="line">    <span class="keyword">const</span> typeInfo = context._typeInfo || <span class="keyword">new</span> TypeInfo(context.getSchema());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      Document: &#123;</span><br><span class="line">        <span class="function"><span class="title">enter</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">          <span class="comment">// 此处的visitor为我们自定的遍历逻辑, 接下来会细讲</span></span><br><span class="line">          visit(node, visitWithTypeInfo(typeInfo, visitor));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">leave</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> cost = visitor.getCost();</span><br><span class="line">          <span class="keyword">if</span> (cost &gt; maxCost) &#123;</span><br><span class="line">            context.reportError(</span><br><span class="line">              createError</span><br><span class="line">                ? createError(cost, node)</span><br><span class="line">                : <span class="keyword">new</span> GraphQLError(formatErrorMessage(cost), [ node ])</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里也贴上<a href="https://npmdoc.github.io/node-npmdoc-graphql/build..beta..travis-ci.org/apidoc.html#apidoc.element.graphql.visitWithTypeInfo"><code>visitWithTypeInfo</code></a>的实现</p></blockquote><p><code>ComplexityVisitor</code>的实现核心为在构造函数中申明需要遍历的<code>Node Type</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.Field = &#123;</span><br><span class="line">  enter: <span class="built_in">this</span>.enterField,</span><br><span class="line">  leave: <span class="built_in">this</span>.leaveField,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来的逻辑就非常简单了, 只需要在<code>enterField</code>和<code>leaveFiled</code>中补充相应的逻辑就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">enterField</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.costFactor *= <span class="built_in">this</span>.getFieldCostFactor();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.cost += <span class="built_in">this</span>.costFactor * <span class="built_in">this</span>.getFieldCost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">leaveField</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.costFactor /= <span class="built_in">this</span>.getFieldCostFactor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有两个函数比较重要, 一个是<code>getFieldCostFactor</code>, 这个函数的作用是当遇到嵌套结构, 例如自定义数据结构或者列表时候, 增大基础的复杂度系数. 另一个为<code>getFieldCost</code>, 这个是计算该<code>node</code>的实际cost, 并累加到总复杂度中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以通过传入配置的方式, 改变不同node的复杂度, 定制自己的复杂度计算规则</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  scalarCost = <span class="number">1</span>,</span><br><span class="line">  objectCost = <span class="number">0</span>,</span><br><span class="line">  listFactor = <span class="number">10</span>,</span><br><span class="line">  ...injectOptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前这样只能仅限于全局设置, 而不能对单个<code>query</code>进行自定义的复杂度计算, 并且对于不同field的开销肯定不同的, 于是我们可以通过拓展<code>extensions</code>的方式, 改变单一<code>field</code>或者<code>list</code>的复杂度. 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directive @cost(value: Int) on FIELD_DEFINITION</span><br><span class="line">directive @costFactor(value: Int) on FIELD_DEFINITION</span><br><span class="line"></span><br><span class="line">type CustomCostItem &#123;</span><br><span class="line">  expensiveField: ExpensiveItem @cost(value: 50)</span><br><span class="line">  expensiveList: [MyItem] @costFactor(value: 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的我们需要更改<code>getFieldCostFactor</code>以及<code>getFieldCost</code>函数的实现, 此处以<code>getFieldCost</code>为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getFieldCost</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 当enter/leave一个node时, context会发生改变</span></span><br><span class="line">  <span class="keyword">const</span> fieldDef = <span class="built_in">this</span>.context.getFieldDef();</span><br><span class="line">  <span class="keyword">if</span> (fieldDef.extensions &amp;&amp; fieldDef.extensions.getCost) &#123;</span><br><span class="line">    <span class="keyword">return</span> fieldDef.extensions.getCost();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.getTypeCost(<span class="built_in">this</span>.context.getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们只需要提供出<code>getCost</code>方法将累加的复杂度结果透出. 在外层的<code>Document.leave</code>处对复杂度总和进行判断, 如果超过之前设置的阈值, 则抛出一个异常即可.</p><p>到这里我们就简单的实现了一个<code>graphql</code>的校验插件, 当然在文章前半部分提到的<code>深度判断</code>也可以用类似的方法快速实现</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>上面所说的查询复杂度计算也存在问题, 我们很难完美的实现对一个query复杂度的判断</p><p>所以这里我们还能通过<code>节流</code>的方式限制服务器处理单一<code>query</code>的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  author(id: &quot;abc&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设执行上面查询的时间为100ms, 我们可以设置服务器处理这个查询的<code>最大服务器时间</code>为600ms, 每隔1s能够增加100ms的<code>服务器时间</code>, 如果服务器的<code>服务器时间</code>不够执行上面的查询, 则拒绝服务. 但是问题是我们需要对上面的查询时间有一个预估, 但这有可能是不准确. </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写这篇文章的契机是因为最近项目中使用到了&lt;code&gt;graphql&lt;/code&gt;, 为了防止接口出现安全问题, 就对&lt;code&gt;graphql&lt;/code&gt;的&lt;code&gt;validation&lt;/code&gt;进行了一点研究. 本文就不对&lt;code&gt;graphql&lt;/code&gt;进行一些介绍了, 如果感兴趣的小伙伴, 可以移步到官网进行阅读&lt;a href=&quot;https://graphql.org/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Front End" scheme="http://rogerwip.tech/categories/Front-End/"/>
    
    
    <category term="Front End" scheme="http://rogerwip.tech/tags/Front-End/"/>
    
    <category term="graphql" scheme="http://rogerwip.tech/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;重构 改善既有代码的设计&gt;&gt;读书笔记</title>
    <link href="http://rogerwip.tech/2021/01/17/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://rogerwip.tech/2021/01/17/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-17T13:21:42.000Z</published>
    <updated>2021-01-18T13:43:36.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>作为博客里读书笔记的第一篇文章, 算是给这个系列开一个头吧, 这里的读书比较呢主要记录的是一本书中自己觉得比较有意思的点, 写下来也是为了加深记忆, 点与点之间可能毫无逻辑可言, 大家如果读到觉得感受不是很好的话也请见谅~</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h3><p>这里文章列举了很多代码坏味道, 比如:</p><a id="more"></a><ul><li>神秘命名</li><li>重复代码</li><li>过长函数</li><li>过长参数列表</li><li>全局数据</li><li>可变数据</li><li>发散式变化</li><li>霰弹式修改<ul><li>每遇到某种变化, 都需要在不同的类中进行小修改</li></ul></li><li>依恋情节<ul><li>与其他模块或者数据交流格外频繁, 甚至超过自身模块</li></ul></li><li>数据泥团<ul><li>多个类中存在相同的数据字段</li></ul></li><li>基本类型偏执<ul><li>执着于使用基本数据类型, 还忽略了抽象</li></ul></li><li>重复的switch<ul><li>可以使用策略模式, map等方式来解决</li></ul></li><li>循环语句<ul><li>多使用pipe的方式, 类似map, reduce, filter等</li></ul></li><li>夸夸其谈的通用性<ul><li>这一点也是需要注意的, 虽然说在开始写代码之前都需要对系统有一个良好的设计, 但是并不意味着需要为以后的功能, 破坏现在代码的可读性, 过度抽象某些类, 需要做的应该是不断的重构优化.</li></ul></li><li>纯数据类<ul><li>指一个类中没有其他的逻辑, 只有数据字段的getter以及setter</li></ul></li><li>注释<ul><li>这一点在文中的说法给我留下了深刻的印象, 不应该用注释来解释阅读性极差的代码, 注释并不是”除臭剂”</li></ul></li></ul><p>接下来是一些书中提到的重构方式</p><h3 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">startDate, endDate</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ====&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">dateRange</span>)</span></span></span><br></pre></td></tr></table></figure><p>配合typescript使用, 效果更佳, 在我实际开发中使用解构来获取函数参数都比过长的参数列表更加优雅, 一方面是可以省去对函数参数顺序的记忆, 另一方面是参数的传入是非常灵活的, 可以对多个参数进行默认值的设置</p><h3 id="以对象取代基本类型"><a href="#以对象取代基本类型" class="headerlink" title="以对象取代基本类型"></a>以对象取代基本类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order.filter(<span class="function"><span class="params">o</span> =&gt;</span> <span class="string">&#x27;high&#x27;</span> === o.priority</span><br><span class="line">  || <span class="string">&#x27;rush&#x27;</span> === o.priority)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====&gt;</span></span><br><span class="line"></span><br><span class="line">order.filter(<span class="function"><span class="params">o</span> =&gt;</span> o.priority.hightThen(<span class="keyword">new</span> Priority(<span class="string">&#x27;normal&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>也许在一开始书写的时候, 第一种写法能够快速的完成需求, 但是随着业务逻辑不断复杂, 对于<code>priority</code>的判断逻辑不断增多以后, 将会逐渐失控, 如果你对Java有一定的接触, 就会很容易的联想实现<code>compare</code>的接口, 我认为都是一种理念, 对于一些数据字段进行功能的扩展</p><h3 id="拆分循环"><a href="#拆分循环" class="headerlink" title="拆分循环"></a>拆分循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> averageAge = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> totalSalary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  averageAge += p.age</span><br><span class="line">  totalSalary = p.salary</span><br><span class="line">&#125;</span><br><span class="line">averageAge /= people.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> averageAge = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  averageAge += p.age</span><br><span class="line">&#125;</span><br><span class="line">averageAge /= people.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> totalSalary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  totalSalary = p.salary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许下面的代码对于很多人来说都是一种坏味道, 甚至我现在也这样觉得, 因为理论上多执行了一次循环, 但是往往在很多的场景中, <strong>循环并不是性能的瓶颈</strong>, 分开书写之后能带来更好的维护性和可读性, 也能方便的拆分代码逻辑</p><h3 id="以多态取代条件表达式"><a href="#以多态取代条件表达式" class="headerlink" title="以多态取代条件表达式"></a>以多态取代条件表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(bird.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a type&#x27;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;b type&#x27;</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a type&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;b type&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用多态处理变体逻辑"><a href="#用多态处理变体逻辑" class="headerlink" title="用多态处理变体逻辑"></a>用多态处理变体逻辑</h3><p>当基类中存在对某种特殊情况进行判断计算时, 可以将这部分逻辑从中分离出来, 因为这样的特殊逻辑过多会混淆视听, 让基础的逻辑难以理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.voyage = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.voyage = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">getVoyageFactor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="built_in">this</span>.getVoyageFactor()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeRating</span> <span class="title">extens</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">getVoyageFactor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将查询函数和修改函数分离"><a href="#将查询函数和修改函数分离" class="headerlink" title="将查询函数和修改函数分离"></a>将查询函数和修改函数分离</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalOutstandingAndSendBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = customer.invoices.reduce(<span class="function">(<span class="params">total, each</span>) =&gt;</span> each.amount + total, <span class="number">0</span>)</span><br><span class="line">  sendBill()</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">totalOutstanding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> customer.invoices.reduce(<span class="function">(<span class="params">total, each</span>) =&gt;</span> each.amount + total, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  sendBill()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原书中有一句话我印象深刻, 明确表现出<code>有副作用</code>与<code>无副作用</code>两种函数之间的差异, 是个很好的想法.</p><p>任何有返回值的函数, 都不应该有看得到的副作用–<code>命令与查询分离</code></p><h3 id="移除标记参数"><a href="#移除标记参数" class="headerlink" title="移除标记参数"></a>移除标记参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDimension</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;height&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._height = value</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;width&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._width = value</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHeight</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._height = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWidth</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._width = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常在开发过程中, 经常会通过传入一些<code>flag</code>来是函数内部的逻辑进行180度的大转变, 往往这样参数的引入会让人难以理解到底那些函数可以调用, 应该如何调用, 正确的做法应该是将<code>flag</code>提取出反映在函数名上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deliveryDate</span>(<span class="params">order, isRush</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ====&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">rushDeliveryDate</span>(<span class="params">order</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">regularDeliveryDate</span>(<span class="params">order</span>)</span></span></span></span><br></pre></td></tr></table></figure><h3 id="保持对象完整"><a href="#保持对象完整" class="headerlink" title="保持对象完整"></a>保持对象完整</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; low, heigh &#125; = dayTempRange</span><br><span class="line">withinRange(low, heigh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===&gt;</span></span><br><span class="line"></span><br><span class="line">withRange(dayTempRange)</span><br></pre></td></tr></table></figure><h3 id="以命令取代函数"><a href="#以命令取代函数" class="headerlink" title="以命令取代函数"></a>以命令取代函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">score</span>(<span class="params">candidate, medicalExam, scoringGuide</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> healthLevel = <span class="number">0</span></span><br><span class="line">  <span class="comment">// long body code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scorer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">candidate, medicalExam, scoringGuide</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.candidate = candidate</span><br><span class="line">    <span class="built_in">this</span>.medicalExam = medicalExam</span><br><span class="line">    <span class="built_in">this</span>.scorginGuide = scoringGuide</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">excute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._result = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>._healthLevel = <span class="number">0</span></span><br><span class="line">    <span class="comment">// long body code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数封装成自己的对象, 有时也是有用的方法, 这种对象我们通常称之为<code>命令对象</code>, 这种对象通常只服务于单一函数, 获得对该函数的请求, 执行该函数, 就是这种对象存在的意义</p><p>与普通的函数相比, 命令对象有更强的表达能力以及更大的控制灵活性. 也可以命令对象增加更多的附加操作, 比如<code>撤销</code></p><h3 id="以委托取代子类"><a href="#以委托取代子类" class="headerlink" title="以委托取代子类"></a>以委托取代子类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">daysToShip</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.priorityDelegate)</span><br><span class="line">      ? <span class="built_in">this</span>._priorityDelegate.daysToShip</span><br><span class="line">      : <span class="built_in">this</span>._warehouse.daysToShip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityOrderDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">daysToShip</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._priorityPlan.daysToShip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的原因有两个:</p><ul><li>继承存在短板, 最明显的是, 继承只能用于处理一个方向上的变化, 比如说我们可能希望’人’的行为根据’年龄段’不同, 并根据’收入水平’不同, 使用继承的话, 子类需要有年轻人, 老人, 也可以是富人以及穷人, 但是不能同时采用两种继承方式</li><li>继承给类之间引入了非常紧密的关系, 任何对超类上的修改, 都会对子类带来影响</li></ul><h2 id="Outro"><a href="#Outro" class="headerlink" title="Outro"></a>Outro</h2><p>是一本值得细细思考的书, 也许之后我会每隔一年会再次翻阅, 相信到时候也会有新的感悟吧</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;作为博客里读书笔记的第一篇文章, 算是给这个系列开一个头吧, 这里的读书比较呢主要记录的是一本书中自己觉得比较有意思的点, 写下来也是为了加深记忆, 点与点之间可能毫无逻辑可言, 大家如果读到觉得感受不是很好的话也请见谅~&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;h3 id=&quot;代码的坏味道&quot;&gt;&lt;a href=&quot;#代码的坏味道&quot; class=&quot;headerlink&quot; title=&quot;代码的坏味道&quot;&gt;&lt;/a&gt;代码的坏味道&lt;/h3&gt;&lt;p&gt;这里文章列举了很多代码坏味道, 比如:&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记一次HHKB`失联`的修复</title>
    <link href="http://rogerwip.tech/2021/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1HHKB-%E5%A4%B1%E8%81%94-%E7%9A%84%E4%BF%AE%E5%A4%8D/"/>
    <id>http://rogerwip.tech/2021/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1HHKB-%E5%A4%B1%E8%81%94-%E7%9A%84%E4%BF%AE%E5%A4%8D/</id>
    <published>2021-01-08T05:48:15.000Z</published>
    <updated>2021-01-17T13:18:33.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随意BB几句"><a href="#随意BB几句" class="headerlink" title="随意BB几句"></a>随意BB几句</h2><p>因为电脑黑屏的关系, 用TimeMachine进行了电脑的备份和恢复, 一切的体验都非常的好直到发现<code>HHKB</code>连不上新电脑的那一刻开始..心态炸裂, 花了大概三个小时最终终于解决了…希望以后遇到这个问题的小伙伴能顺利解决</p><a id="more"></a><h2 id="正文-问题表现"><a href="#正文-问题表现" class="headerlink" title="正文: 问题表现"></a>正文: 问题表现</h2><p>键盘: <strong>HHKB Hybrid Type-s 双模版本</strong><br>电脑: <strong>macbook</strong></p><p>表现为蓝牙一直无法稳定的链接到电脑上, 无论是有线或者无线的模式, 在系统蓝牙管理页面处可以看到<code>HHKB</code>的图标一直上下闪烁, 最终无法连接成功导致键盘无法正常工作</p><p><a href="https://imgchr.com/i/sumv5D"><img src="https://s3.ax1x.com/2021/01/08/sumv5D.png" alt="sumv5D.png"></a></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>键盘开机</li><li>按住<code>Fn + Q</code>进入配对模式, 表现为蓝色的灯一直闪烁</li><li>再按住<code>Fn + Z + ~</code>键清空键盘蓝牙配对信息, 键盘会自动关闭, 灯会变成橙色</li><li>再长按开关键重新打开键盘, 按住<code>Fn + Q</code>重新进行进入配对模式</li><li>按住<code>Fn + Control + 1/2/3/4</code>, 指定1,2,3,4任意一个序号, 之后电脑重新搜索蓝牙就可以找到你刚才用的序号命名的键盘了, 再次连接<strong>键盘就恢复了</strong></li></ul><p>这里也附上我找到的关于<code>HHKB</code>蓝牙相关设置的按键组合</p><p><a href="https://imgchr.com/i/sutEdJ"><img src="https://s3.ax1x.com/2021/01/08/sutEdJ.png" alt="sutEdJ.png"></a></p><h2 id="高级操作-常规操作"><a href="#高级操作-常规操作" class="headerlink" title="高级操作(常规操作)"></a>高级操作(常规操作)</h2><p>为什么会存在设置蓝牙序号这样的操作呢, 这其实也是<code>HHKB</code>的一个feature吧, 多设备间的快速切换, 最多可以连接四台设备(包括mac, ios, windows, android), 只需要提前对四个设备设置不同的键盘编号即可. 直接按下<code>Fn + Control + 1/2/3/4</code>就可以做到秒级的设备切换, 这是<code>filco</code>之类的键盘无法做到的.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;随意BB几句&quot;&gt;&lt;a href=&quot;#随意BB几句&quot; class=&quot;headerlink&quot; title=&quot;随意BB几句&quot;&gt;&lt;/a&gt;随意BB几句&lt;/h2&gt;&lt;p&gt;因为电脑黑屏的关系, 用TimeMachine进行了电脑的备份和恢复, 一切的体验都非常的好直到发现&lt;code&gt;HHKB&lt;/code&gt;连不上新电脑的那一刻开始..心态炸裂, 花了大概三个小时最终终于解决了…希望以后遇到这个问题的小伙伴能顺利解决&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://rogerwip.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="http://rogerwip.tech/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>用Rust写一个CLI工具</title>
    <link href="http://rogerwip.tech/2021/01/07/%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AACLI%E5%B7%A5%E5%85%B7/"/>
    <id>http://rogerwip.tech/2021/01/07/%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AACLI%E5%B7%A5%E5%85%B7/</id>
    <published>2021-01-07T14:25:44.000Z</published>
    <updated>2021-01-17T13:18:33.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><strong>Lingling insurance</strong></p><p>自己刚开始学习Rust不久, 写这个简单的cli也是为了练手, 代码不优雅也请各路大神指点, 我定虚心求教! 起初接触到rust是因为WebAssembly, 有不少人用rust编译为WSAM, 作为一个合格的前端娱乐圈工作者, 还是希望对此有一定的了解. </p><p>该CLI实现一个持久化的TODO list. 那废话不多说, 咱们开始吧!</p><a id="more"></a><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h2><h3 id="1-1-rust安装"><a href="#1-1-rust安装" class="headerlink" title="1.1 rust安装"></a>1.1 rust安装</h3><p>如果你是用的是Macos或者是linux都可以简单的通过下面的命令安装rust</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &lt;https://sh.rustup.rs&gt; -sSf | sh</span><br></pre></td></tr></table></figure><p>如果你使用的window系统, 可以上<a href="https://rustup.rs/">rustup</a>下载对应exe文件.</p><h3 id="1-2-cargo的使用"><a href="#1-2-cargo的使用" class="headerlink" title="1.2 cargo的使用"></a>1.2 cargo的使用</h3><p><code>cargo</code>是<code>rust</code>包内自带的包管理工具, 类似npm, 同时也提供了一些cli来编译或者初始化一个项目</p><blockquote><p>cargo init</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个项目</span><br><span class="line">cargo init xxx-project </span><br></pre></td></tr></table></figure><p>执行结束以后会在执行目录下生产下面的目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">  .git/</span><br><span class="line">  |</span><br><span class="line">  .gitignore</span><br><span class="line">  |</span><br><span class="line">  Cargo.toml</span><br><span class="line">  |</span><br><span class="line">  src/</span><br></pre></td></tr></table></figure><p>其中需要解释的是<code>Cargo.toml</code>文件, 其作用和<code>npm</code>中<code>package.json</code>相同, 对项目信息和包依赖进行一些说明</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rust-cli&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;rogerjluo&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br><span class="line"><span class="attr">clap</span> = <span class="string">&quot;~2.32&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">chrono</span> = <span class="string">&quot;0.4&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>cargo build</p></blockquote><p>改命令是将项目进行预编译, 安装你在toml文件中的依赖至<code>target</code>文件夹内, 并生成或者更新<code>Cargo.lock</code>文件对依赖的版本进行管理(作用类似package-lock.json).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">   Compiling proc-macro2 v1.0.24</span><br><span class="line">   Compiling autocfg v1.0.1</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">   Compiling chrono v0.4.19</span><br><span class="line">   Compiling rust-cli v0.1.0 (/Users/rogerjluo/Documents/project/rust-cli)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 28.25s</span><br></pre></td></tr></table></figure><blockquote><p>cargo run build</p></blockquote><p>编译后执行二进制文件, 比如在<code>src/main.rs</code>文件中写入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo run build</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.03s</span><br><span class="line">     Running `target/debug/rust-cli build`</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="2-文件存储和读取"><a href="#2-文件存储和读取" class="headerlink" title="2. 文件存储和读取"></a>2. 文件存储和读取</h2><p>因为我们要做一个持久化数据的todolist, 所以文件操作是必不可少的, 这里就用到了标准库中的<code>std::io::&#123;Read, Write&#125;</code>以及<code>std::fs</code>.</p><p>首先我们需要声明一些<code>struct</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InternalFile</span></span> &#123;</span><br><span class="line">  path: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> data: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> actual_size: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileSystem</span></span> &#123;</span><br><span class="line">  files: HashMap&lt;<span class="built_in">String</span>, InternalFile&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写文件</p></blockquote><p>这里使用HashMap的原因是不希望多次写文件, 所以将多次写入操作合并之后再写入.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将写入数据先写入到内存中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>, data: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">  <span class="keyword">self</span>.files.insert(</span><br><span class="line">    calculate_hash(&amp;path.to_string().as_bytes()),</span><br><span class="line">    InternalFile &#123;</span><br><span class="line">      path: path.to_string(),</span><br><span class="line">      data: data.to_string(),</span><br><span class="line">      actual_size: data.len(),</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件系统数据转存到文件</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">save</span></span>&lt;T: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(&amp;<span class="keyword">self</span>, path: T) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> f = fs::File::create(&amp;path).unwrap();</span><br><span class="line">  <span class="keyword">for</span> (_, file) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.files &#123;</span><br><span class="line">    f.write(&amp;file.data.as_bytes()).unwrap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读文件</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">load</span></span>(&amp;<span class="keyword">self</span>, path: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path_name = Path::new(&amp;path);</span><br><span class="line">  <span class="keyword">let</span> display = path_name.display();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="keyword">match</span> File::open(&amp;path_name) &#123;</span><br><span class="line">    <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">    <span class="literal">Err</span>(_why) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果文件不存在则创建一个文件</span></span><br><span class="line">      <span class="keyword">self</span>.save(path);</span><br><span class="line">      <span class="built_in">panic!</span>(<span class="string">&quot;文件不存在, 已经新建存储文件, 请重试&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  <span class="keyword">match</span> file.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">    <span class="literal">Err</span>(why) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;无法打开文件 &#123;&#125;: &#123;&#125;&quot;</span>, display,</span><br><span class="line">    why.to_string()),</span><br><span class="line">    <span class="literal">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  s <span class="comment">// 返回文件内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-JSON的序列化和反序列化"><a href="#3-JSON的序列化和反序列化" class="headerlink" title="3. JSON的序列化和反序列化"></a>3. JSON的序列化和反序列化</h2><p>当然为了方便对文件内容进行操作, 我们对写入和读取进行了序列化和反序列的过程, 使用到的是<code>serde_json</code>, 实现类似JS中的<code>JSON.parse</code>以及<code>JSON.stringify</code></p><blockquote><p>序列化</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serde_json::to_string(TodoList)</span><br></pre></td></tr></table></figure><blockquote><p>反序列化</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data: TodoList = <span class="keyword">match</span> serde_json::from_str(&amp;file) &#123;</span><br><span class="line">  <span class="literal">Ok</span>(x) =&gt; x,</span><br><span class="line">  <span class="literal">Err</span>(_why) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果文件为空或者出错, 则创建一个空的list返回</span></span><br><span class="line">    TodoList &#123;</span><br><span class="line">      todos: HashMap::new(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们是可以指定反序列化的目标结构, 如果结构不匹配则无法完成反序列化, 但是前提是需要在<code>struct</code>上加上一些声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TodoTask</span></span> &#123;</span><br><span class="line">  content: <span class="built_in">String</span>,</span><br><span class="line">  is_done: <span class="built_in">bool</span>,</span><br><span class="line">  c_time: <span class="built_in">String</span>,</span><br><span class="line">  u_time: <span class="built_in">String</span>,</span><br><span class="line">  index: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TodoList</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> todos: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Vec</span>&lt;TodoTask&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-clap"><a href="#4-clap" class="headerlink" title="4. clap"></a>4. clap</h2><p>基础的功能有了, 接下来我们需要获取命令行中传入的参数并执行不同的逻辑, <code>cargo</code>中 <code>cargo run -- [参数]</code>可以将参数传入到程序中, 但我们这里将使用一个叫做<code>clap</code>的库来简化这个过程.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> help_instru = r#<span class="string">&quot;命令名:</span></span><br><span class="line"><span class="string">    add(a)          -p [Content]                  : 添加当天的todo</span></span><br><span class="line"><span class="string">    list_all(la)                                  : 打印全部todo</span></span><br><span class="line"><span class="string">    list_daily(ld)  -p [Date: YYYY-MM-DD]         : 打印某一天的todo, 不带参数默认打印当天</span></span><br><span class="line"><span class="string">    remove(rm)      -p [Date: YYYY-MM-DD] [Index] : 删除某一项todo</span></span><br><span class="line"><span class="string">    toggle(t)       -p [Date: YYYY-MM-DD] [Index] : 改变某一项todo的状态, 完成/待完成</span></span><br><span class="line"><span class="string">    list_week(lw)   -p [Date: YYYY-MM-DD]         : 打印某一周的todo, 方便生成周报</span></span><br><span class="line"><span class="string">  &quot;</span>#;</span><br><span class="line">  <span class="keyword">let</span> matches = App::new(<span class="string">&quot;Todo&quot;</span>)</span><br><span class="line">    .version(<span class="string">&quot;0.0.1&quot;</span>)</span><br><span class="line">    .author(<span class="string">&quot;rogerjluo&quot;</span>)</span><br><span class="line">    .about(<span class="string">&quot;rust实现的todolist&quot;</span>)</span><br><span class="line">    .arg(Arg::with_name(<span class="string">&quot;MODE&quot;</span>)</span><br><span class="line">      .short(<span class="string">&quot;m&quot;</span>)</span><br><span class="line">      .long(<span class="string">&quot;mode&quot;</span>)</span><br><span class="line">      .takes_value(<span class="literal">true</span>)</span><br><span class="line">      .help(help_instru))</span><br><span class="line">    .arg(Arg::with_name(<span class="string">&quot;PARAMETERS&quot;</span>)</span><br><span class="line">      .short(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">      .long(<span class="string">&quot;params&quot;</span>)</span><br><span class="line">      .multiple(<span class="literal">true</span>)</span><br><span class="line">      .takes_value(<span class="literal">true</span>)</span><br><span class="line">      .help(<span class="string">&quot;参数&quot;</span>))</span><br><span class="line">    .get_matches();</span><br></pre></td></tr></table></figure><p>进行了声明之后, 我们如何在程序中获取到传入的参数呢</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是参数只支持单个value, 此处match的名字与之前声明的Arg::with_name(&quot;MODE&quot;)对应</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(mode) = matches.value_of(<span class="string">&quot;MODE&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">match</span> mode &#123;</span><br><span class="line">    <span class="string">&quot;add&quot;</span> =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;list_all&quot;</span> =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;没有此命令&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持multiple value</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">  <span class="keyword">let</span> date = p_list[<span class="number">0</span>]; <span class="comment">// 参数一</span></span><br><span class="line">  <span class="keyword">let</span> index = p_list[<span class="number">1</span>]; <span class="comment">// 参数二</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;请输入参数: -p [Date: YYYYMMDD] [Index] \n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-举个栗子-🌰"><a href="#5-举个栗子-🌰" class="headerlink" title="5. 举个栗子 🌰"></a>5. 举个栗子 🌰</h2><p>这里我们只列举其中的两个具体实现~ 如果感兴趣可以去仓库中查看别的代码, 代码地址在文末.</p><blockquote><p>写入一项todo</p></blockquote><p>这里我们只写入当天的todo, 所以传入的参数只需要写入的内容即可, 命令为: <code>cargo run -- -m add -p HelloWorld</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;add&quot;</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">    <span class="keyword">let</span> content = p_list[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// add_task的作用就是将新的todo插入到对应日期的todo列表中, 这里就不列举代码了</span></span><br><span class="line">    <span class="keyword">let</span> newlist = task::add_task(data, content.to_string());</span><br><span class="line">    file_system.write(<span class="string">&quot;todo&quot;</span>, &amp;serde_json::to_string(&amp;TodoList &#123;</span><br><span class="line">      todos: newlist</span><br><span class="line">    &#125;).unwrap());</span><br><span class="line">    file_system.save(file_name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;请输入参数: -p [Content] \n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行后, 我们会看到指定写入文件内会有下面的信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;todos&quot;</span>:&#123;<span class="attr">&quot;2020-12-12&quot;</span>:[&#123;<span class="attr">&quot;content&quot;</span>:<span class="string">&quot;HelloWorld&quot;</span>,<span class="attr">&quot;is_done&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;c_time&quot;</span>:<span class="string">&quot;2020-12-12 07:21:31&quot;</span>,<span class="attr">&quot;u_time&quot;</span>:<span class="string">&quot;2020-12-12 07:21:31&quot;</span>,<span class="attr">&quot;index&quot;</span>:<span class="string">&quot;0&quot;</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>列举某一天所在周的全部todo</p></blockquote><p>我们要实现这个功能, 需要计算出某一日期所在的周在该年中的index, 这里借助了<code>chrono</code>库提供的api实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::prelude::*;</span><br><span class="line"><span class="keyword">use</span> chrono::&#123;NaiveDate&#125;;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_weekday_index</span></span>(date: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> utc = NaiveDate::parse_from_str(date, <span class="string">&quot;%Y-%m-%d&quot;</span>).unwrap();</span><br><span class="line">  <span class="comment">// utc.ordinal()可以获取日期在该年中的index</span></span><br><span class="line">  <span class="keyword">let</span> day_index = utc.ordinal();</span><br><span class="line">  (day_index / <span class="number">7</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;list_week&quot;</span> | <span class="string">&quot;lw&quot;</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> date;</span><br><span class="line">  <span class="comment">// 这里判断是否传入日期参数, 没有传入默认为当天</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">    date = p_list[<span class="number">0</span>].to_string();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    date = util::get_cur_ymd();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> week_index = util::get_weekday_index(&amp;date);</span><br><span class="line">  <span class="keyword">for</span> val <span class="keyword">in</span> data.todos.keys() &#123;</span><br><span class="line">    <span class="keyword">let</span> c_week_index = util::get_weekday_index(val);</span><br><span class="line">    <span class="comment">// 判断是否在同一周, 如果是则打印</span></span><br><span class="line">    <span class="keyword">if</span> c_week_index == week_index &#123;</span><br><span class="line">      task::list_daily(&amp;data, val.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行命令为: <code>cargo run -- -m lw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo run -- -m lw               </span><br><span class="line">   Compiling rust-cli v0.1.0 (/Users/rogerjluo/Documents/project/rust-cli)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 2.00s</span><br><span class="line">     Running `target/debug/rust-cli -m lw`</span><br><span class="line"></span><br><span class="line">2020-12-12:</span><br><span class="line"></span><br><span class="line">0. [Need Handle] HelloWorld</span><br></pre></td></tr></table></figure><h2 id="6-结尾"><a href="#6-结尾" class="headerlink" title="6. 结尾"></a>6. 结尾</h2><p>文章只是介绍了项目中的部分代码以及功能, 完整版已经实现的功能包括:</p><ul><li>写入新的todo</li><li>更改todo状态, 待处理和已完成间进行切换</li><li>删除某个todo</li><li>列出所有todo</li><li>列出本周的todo list</li><li>列出某一天的todo list</li></ul><p>(这里没有列出所有的代码, 如果你感兴趣, 请移步到: <a href="https://github.com/RogerZZZZZ/rust-todo-cli">git</a>) 如果觉得还不错, 帮忙点个star吧, 初学者举步维艰</p><p>如果大家对代码有什么建议的话希望能告诉我, 这将继续鞭策我前进, 感谢~</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Lingling insurance&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自己刚开始学习Rust不久, 写这个简单的cli也是为了练手, 代码不优雅也请各路大神指点, 我定虚心求教! 起初接触到rust是因为WebAssembly, 有不少人用rust编译为WSAM, 作为一个合格的前端娱乐圈工作者, 还是希望对此有一定的了解. &lt;/p&gt;
&lt;p&gt;该CLI实现一个持久化的TODO list. 那废话不多说, 咱们开始吧!&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="http://rogerwip.tech/categories/rust/"/>
    
    <category term="瞎折腾" scheme="http://rogerwip.tech/categories/rust/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="rust" scheme="http://rogerwip.tech/tags/rust/"/>
    
    <category term="cli" scheme="http://rogerwip.tech/tags/cli/"/>
    
  </entry>
  
</feed>
